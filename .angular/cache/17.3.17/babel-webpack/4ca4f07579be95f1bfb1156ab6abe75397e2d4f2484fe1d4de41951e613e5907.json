{"ast":null,"code":"import { ReplaySubject, of } from 'rxjs';\nimport { shareReplay, tap, catchError } from 'rxjs/operators';\nimport { SERVER_API_URL } from '@app/app.constants';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./state-storage.service\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"./websocket-auth.service\";\nexport class AccountService {\n  constructor(http, stateStorageService, router, websocketService) {\n    this.http = http;\n    this.stateStorageService = stateStorageService;\n    this.router = router;\n    this.websocketService = websocketService;\n    this.userIdentity = null;\n    this.authenticationState = new ReplaySubject(1);\n  }\n  save(account) {\n    return this.http.post(SERVER_API_URL + '/api/v1/account', account);\n  }\n  update(account) {\n    return this.http.put(SERVER_API_URL + '/api/v1/account', account);\n  }\n  authenticate(identity) {\n    this.userIdentity = identity;\n    this.authenticationState.next(this.userIdentity);\n    if (identity) {\n      this.websocketService.connect();\n    } else {\n      this.websocketService.disconnect();\n    }\n  }\n  hasAnyAuthority(authorities) {\n    if (!this.userIdentity?.authorities) {\n      return false;\n    }\n    if (!Array.isArray(authorities)) {\n      authorities = [authorities];\n    }\n    return this.userIdentity.authorities.some(authority => authorities.includes(authority));\n  }\n  identity(force) {\n    if (!this.accountCache$ || force || !this.isAuthenticated()) {\n      this.accountCache$ = this.fetch().pipe(catchError(() => {\n        return of(null);\n      }), tap(account => {\n        this.authenticate(account);\n        if (account) {\n          this.navigateToStoredUrl();\n        }\n      }), shareReplay());\n    }\n    return this.accountCache$;\n  }\n  isAuthenticated() {\n    return this.userIdentity !== null;\n  }\n  getAuthenticationState() {\n    return this.authenticationState.asObservable();\n  }\n  getImageUrl() {\n    return this.userIdentity ? this.userIdentity.imageUrl : '';\n  }\n  fetch() {\n    return this.http.get(SERVER_API_URL + '/api/v1/account');\n  }\n  navigateToStoredUrl() {\n    // previousState can be set in the authExpiredInterceptor and in the userRouteAccessService\n    // if login is successful, go to stored previousState and clear previousState\n    const previousUrl = this.stateStorageService.getUrl();\n    if (previousUrl) {\n      this.stateStorageService.clearUrl();\n      this.router.navigateByUrl(previousUrl);\n    }\n  }\n  static {\n    this.ɵfac = function AccountService_Factory(t) {\n      return new (t || AccountService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.StateStorageService), i0.ɵɵinject(i3.Router), i0.ɵɵinject(i4.WebsocketAuthService));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AccountService,\n      factory: AccountService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["ReplaySubject","of","shareReplay","tap","catchError","SERVER_API_URL","AccountService","constructor","http","stateStorageService","router","websocketService","userIdentity","authenticationState","save","account","post","update","put","authenticate","identity","next","connect","disconnect","hasAnyAuthority","authorities","Array","isArray","some","authority","includes","force","accountCache$","isAuthenticated","fetch","pipe","navigateToStoredUrl","getAuthenticationState","asObservable","getImageUrl","imageUrl","get","previousUrl","getUrl","clearUrl","navigateByUrl","i0","ɵɵinject","i1","HttpClient","i2","StateStorageService","i3","Router","i4","WebsocketAuthService","factory","ɵfac","providedIn"],"sources":["/home/kojo/work/JojoAddisonDev/kojo-stack/src/app/core/auth/account.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, ReplaySubject, of } from 'rxjs';\nimport { shareReplay, tap, catchError } from 'rxjs/operators';\nimport { WebsocketAuthService } from './websocket-auth.service';\nimport { SERVER_API_URL } from '@app/app.constants';\nimport { Account } from '../login/account.model';\nimport { StateStorageService } from './state-storage.service';\n\n@Injectable({ providedIn: 'root' })\nexport class AccountService {\n  private userIdentity: Account | null = null;\n  private readonly authenticationState = new ReplaySubject<Account | null>(1);\n  private accountCache$?: Observable<Account | null>;\n\n  constructor(\n    private readonly http: HttpClient,\n    private readonly stateStorageService: StateStorageService,\n    private readonly router: Router,\n    private readonly websocketService: WebsocketAuthService\n  ) {}\n\n  save(account: Account): Observable<{}> {\n    return this.http.post(SERVER_API_URL + '/api/v1/account', account);\n  }\n\n  update(account: Account): Observable<{}> {\n    return this.http.put(SERVER_API_URL + '/api/v1/account', account);\n  }\n\n  authenticate(identity: Account | null): void {\n    this.userIdentity = identity;\n    this.authenticationState.next(this.userIdentity);\n    if (identity) {\n      this.websocketService.connect();\n    } else {\n      this.websocketService.disconnect();\n    }\n  }\n\n  hasAnyAuthority(authorities: string[] | string): boolean {\n    if (!this.userIdentity?.authorities) {\n      return false;\n    }\n    if (!Array.isArray(authorities)) {\n      authorities = [authorities];\n    }\n    return this.userIdentity.authorities.some((authority: string) => authorities.includes(authority));\n  }\n\n  identity(force?: boolean): Observable<Account | null> {\n    if (!this.accountCache$ || force || !this.isAuthenticated()) {\n      this.accountCache$ = this.fetch().pipe(\n        catchError(() => {\n          return of(null);\n        }),\n        tap((account: Account | null) => {\n          this.authenticate(account);\n          if (account) {\n            this.navigateToStoredUrl();\n          }\n        }),\n        shareReplay()\n      );\n    }\n    return this.accountCache$;\n  }\n\n  isAuthenticated(): boolean {\n    return this.userIdentity !== null;\n  }\n\n  getAuthenticationState(): Observable<Account | null> {\n    return this.authenticationState.asObservable();\n  }\n\n  getImageUrl(): string {\n    return this.userIdentity ? this.userIdentity.imageUrl : '';\n  }\n\n  private fetch(): Observable<Account> {\n    return this.http.get<Account>(SERVER_API_URL + '/api/v1/account');\n  }\n\n  private navigateToStoredUrl(): void {\n    // previousState can be set in the authExpiredInterceptor and in the userRouteAccessService\n    // if login is successful, go to stored previousState and clear previousState\n    const previousUrl = this.stateStorageService.getUrl();\n    if (previousUrl) {\n      this.stateStorageService.clearUrl();\n      this.router.navigateByUrl(previousUrl);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}